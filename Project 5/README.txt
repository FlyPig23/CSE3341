- Name: Hangxiao Zhu

- Files: Project5.zip Project5, README, Assign.java, Cmpr.java, Cond.java, Core.java, Decl.java, DeclClass.java, DeclInt.java, DeclSeq.java, Executor.java, Expr.java, Factor.java, Formals.java, FuncCall.java, FuncDecl.java, GarbageCollector.java, Id.java, IdList.java, If.java, In.java, Loop.java, Main.java, Out.java, Parser.java, Program.java, Scanner.java, Stmt.java, StmtSeq.java, Term.java

- Special features: Retain the consistency of almost all codes of different classes, i.e., basically each independent class contains three basic methods: parse, semantic, print and execute; Implement an ArrayList to keep track of the reference counts.

- Description of the overall design: The overall structure is based on Project 4. The first step was to create a GarbageCollector class, which manipulates the increment and decrement in the garbageCollector list. According to the reference-count rule, "id = new" makes the id's reference count to be 1, and "id = ref id" makes different changes to the left side id's reference in different situations. Besides, after each frame finishes, their local id's reference counts will be zero. Based on these rules, I decided to add allocateToGarbageCollector(), addToGarbageCollector(String id), subFromGarbageCollector(String id), checkReachZero(String id), countTotalReference() to GarbageCollector.class. The allocateToGarbageCollector() is the function to add additional positions to the reference count list. The addToGarbageCollector(String id) is the function to add one to the corresponding id's reference count. The subFromGarbageCollector(String id) is the function to subtract one from the corresponding id's reference count. The checkReachZero(String id) is the function to check whether the corresponding id's reference count reaches zero and decide whether to print "gc:" information. The countTotalReference() is the function to count current number of reachable values on the heap. Then I started to modify execute() functions in Assign.java, If.java, Loop.java, Program.java, FuncCall.java, because execute process is where the number of reachable values on heap could change. During the modification, I also added some helper functions to Executor.java, including subFromGarbageCollectorBeforeFrameEnd(), subFromGarbageCollectorBeforeIfAndLoopEnd(), and some modifications to pushStackForCall(Formals formal, Formals actual) function. The subFromGarbageCollectorBeforeFrameEnd() function is meant to erase each frame's local id's reference count. The subFromGarbageCollectorBeforeIfAndLoopEnd() is meant to erase each if or loop block's local id's reference count. The modifications to pushStackForCall(Formals formal, Formals actual) function are meant to add one to an id's reference count when it is used by a function call. 

- Test Process: I first ran the tester.sh file to see how many test cases failed. At first I got confused about what I needed to print. The project asked us to print the current number of reachable values and I mistakenly thought we needed to print the sum of the reference count of all the ids. After solving this problem, I passed 9 test cases but I still failed 5.code. 5.code includes a function call and a "id = ref id" sentence. I suspected the problem might lie in these two places. Therefore I added print to execute() function in FuncCall.java and subFromGarbageCollectorBeforeFrameEnd() function in Executor(). By printing the stackSpace and the garbageCollector list, I tracked where the problem was. It was because I didn't use checkReachZero(String id) function at the beginning, instead, I let subFromGarbageCollector(String id) function to check whether a reference count reaches zero. This led to â€œrepeat printing 'gc:'" problem. After fixing this problem, I added some more test cases and my code worked well.


- Bugs: No bug remaining.



